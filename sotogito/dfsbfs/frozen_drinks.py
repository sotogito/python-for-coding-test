"""
근데 왜 이 로직이 DFS인걸까???????? 0,0하나의 좌표로부터 시작해서 상,하,좌,우로 뻗어나가면..
깊에 뿌리를 내린다는 로직보다는 BFS에 좀 더 가까운 느낌이 드는데?

근데 찾아보니 사실 깊게 뿌리리를 내리는 동작이 맞다!
(0,0)으로 시작해서 0이 없을 떄까지 상하좌우 재귀호출이 일어난다.
이 각각의 호출 이전 호출이 완료된 뒤에야 진행된다. 즉 (0,0)이 0인지 확인된 후에 상하좌우를 상핀다는거다.
각각 상하좌우도 0임이 확인되어야 다음 경로를 탐색한다.
즉, 재귀 호출이 하나의 깊은 경로를 따라 진행된 후, 다른 방향으로 돌아가며 탐색을 진행하게된다.


그럼 BFS라면 어떻게 동작했을까?
BFS는 모든 방향을 동시에 탐색한다.
1 2 3
4 5 6
7 8 9
위와같은 좌표가 있다면

시작점: 1

큐: [1]
방문 순서: 1
인접한 숫자 2와 4를 큐에 추가.
큐: [2, 4]
큐에서 숫자 꺼냄: 2

큐: [4]
방문 순서: 1 -> 2
2의 인접한 숫자는 3과 5. 이 둘을 큐에 추가.
큐: [4, 3, 5]
큐에서 숫자 꺼냄: 4

큐: [3, 5]
방문 순서: 1 -> 2 -> 4
4의 인접한 숫자는 7과 5. 5는 이미 큐에 있으므로 7만 큐에 추가.
큐: [3, 5, 7]
큐에서 숫자 꺼냄: 3

큐: [5, 7]
방문 순서: 1 -> 2 -> 4 -> 3
3의 인접한 숫자는 6. 큐에 추가.
큐: [5, 7, 6]
큐에서 숫자 꺼냄: 5

큐: [7, 6]
방문 순서: 1 -> 2 -> 4 -> 3 -> 5
5의 인접한 숫자는 6과 8. 6은 이미 큐에 있으므로 8만 큐에 추가.
큐: [7, 6, 8]
큐에서 숫자 꺼냄: 7

큐: [6, 8]
방문 순서: 1 -> 2 -> 4 -> 3 -> 5 -> 7
7의 인접한 숫자는 8. 이미 큐에 있으므로 추가하지 않음.
큐: [6, 8]
큐에서 숫자 꺼냄: 6

큐: [8]
방문 순서: 1 -> 2 -> 4 -> 3 -> 5 -> 7 -> 6
6의 인접한 숫자는 9. 큐에 추가.
큐: [8, 9]
큐에서 숫자 꺼냄: 8

큐: [9]
방문 순서: 1 -> 2 -> 4 -> 3 -> 5 -> 7 -> 6 -> 8
8의 인접한 숫자는 9. 이미 큐에 있으므로 추가하지 않음.
큐: [9]
큐에서 숫자 꺼냄: 9

큐: []
방문 순서: 1 -> 2 -> 4 -> 3 -> 5 -> 7 -> 6 -> 8 -> 9
큐가 이제 비어있으므로 BFS 탐색이 종료됩니다.

BFS는 위와 같은 순서로 진행된다.

DFS 탐색 방식: DFS는 한 경로를 가능한 깊이까지 탐색한 후, 더 이상 갈 수 없을 때 다른 경로로 돌아와서 다시 깊이 탐색을 이어가는 방식
BFS 탐색 방식: BFS는 시작점에서 가까운 노드들(인접한 노드들)부터 차례대로 탐색합니다. 먼저 현재 레벨의 모든 노드를 방문한 후, 다음 레벨로 넘어가서 탐색
"""


n, m = map(int, input().split())

graph = []
for _ in range(n):
    graph.append(list(map(int, input()))) #note 공백 없이 받기 떄문에 split() 이 필요 없음
    #graph.append(list(map(int, input().split()))) 이건 왜 안되지


def dfs(x, y):
    if x < 0 or x >= n or y < 0 or y >= m: # 벗어날 경우, index가 0보다 작거나 n,m보다 같거나 크면 안됨
        return False

    if graph[x][y] == 0:
        graph[x][y] = 1 #note 이미 방문한 좌표를 1로 변경하여 재귀를 막음

        # note 각각 재귀로 상하좌우가 0이면 계속 재귀로 돌고 벗어나는 조건에서 ture를 반환하여 count함
        # note 즉 아래 재귀는 0이 아닐떄까지 하게됨
        dfs(x, y + 1)
        dfs(x, y - 1)
        dfs(x - 1, y)
        dfs(x + 1, y)
        return True
    return False # note 좌표값이 1일 경우는 재귀를 돌지 않음


count = 0
for i in range(n):
    for j in range(m):
        if dfs(i, j):
            count += 1

print(count)
