# 정렬 Sorting

데이터를 특정한 기준에 따라서 순서대로 나열하는 것.

---

### ⏱ 선택 정렬

- 모든 원소를 비교하여 정렬
- 시간 복잡도가 비효율적임.
- 특정한 리스트에 작은 데이터를 찾는 코딩테스트에서는 자주 사용함.

1. 가장 작은 데이터를 선택한다.
2. 맨 앞에있는 숫자와 바꾼다.

```python
array = [7, 5, 9, 0]
for i in range(len(array)):
    min_index = i
    for j in range(i + 1, len(array)): # 가장 작은 숫자를 구하는 for문
        if array[min_index] > array[j]:  # min 보다 더 작은 수인지 확인
            min_index = j
    array[i], array[min_index] = array[min_index], array[i]  # 스와프
```

### ⏱ 삽입 정렬

- 데이터가 거의 정렬 되어있을 때 효율적

1. 리스트의 두번째 요소부터 시작
2. 현재 요소를 이미 정렬된 요소와 비교하면서 적정한 위치를 찾음
3. 해당 위치에 삽입

```python
array = [7, 5, 9, 0]
for i in range(1, len(array)):
    for j in range(i, 0, -1):  # 현재 요소를 앞쪽으로 한 칸씩 비교하면서 삽입할 위차를 찾음.
        if array[j] < array[j - 1]:  # 비교하여 삽입할 조건
            array[j], array[j - 1] = array[j - 1], array[j]
        else:
            break
```

### ⏱ 퀵 정렬

- 빠름
- 단, 이미 데이터가 정렬되어 있는 경우 오히려 느림
- 숫자를 교환하기 위한 기준 '피벗'이 사용됨
- 재귀 사용
    - 재귀 종료 조건 : 리스트 데이터 개수가 1개인 경우

#### 파트 1

- 호어 분할 방식 : 배열의 양 끝에서 시작하여 중앙으로 모이면서, 각 right, left 포인터들이 피벗보다 큰 값과 작은 값을 분할한다.
- 분할, 파티션 : 아래의 과정을 거치고 나면, 피벗의 왼쪽에서는 피벗보다 작은 데이터, 오른쪽에는 큰 데이터가 위치하게 된다.

1. 첫 번째 데이터를 피벗으로 설정한다.
2. 피벗 다음 데이터와, 오른쪽 데이터를 하나씩 비교하며 피벗보다 작으면 왼쪽, 크면 오른쪽으로 교환한다.

#### 파트 2

- 파트1에서 피벗의 기준으로 나눠진 2 파트에 또! 각각의 피벗을 정해서 동일한 방식으로 정렬한다.

#### 파트 3

- 다시 동일한 방식으로 피벗을 정해서 정렬한다.

```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]


def quick_sort(array, start, end):
    # 재귀 종료 조건 : 원소가 1개인 경우
    if start >= end:
        return

    pivot = start
    left = start + 1  # 오른쪽으로 이동하면서 피벗보다 큰 값을 찾음
    right = end  # 왼쪽으로 이동하면서 피벗보다 작은 값을 찾음
    # 오름차순으로 정렬
    while left <= right:
        # 피벗보다 큰 데이터를 찾을 떄까지 반복 : 피벗의 오른쪽 data
        while left <= end and array[left] <= array[pivot]:
            left += 1
        # 피벗보다 작은 데이터를 찾을 떄까지 반복 : 피벗의 왼쪽 data
        while right > start and array[right] >= array[pivot]:
            right -= 1

        # 왼쪽 포인터와 오른쪽 포인터가 서로 교차하여 지나칠때
        if left > right:  # 값이 아니라 인덱스를 비교하고있음
            array[right], array[pivot] = array[pivot], array[right]
        # 작은 데이터와 큰 데이터를 교체
        else:
            array[left], array[right] = array[right], array[left]

    # 재귀
    quick_sort(array, start, right - 1)  # 피벗 기준 왼쪽
    quick_sort(array, right, end)  # 피벗 기준 오른쪽


quick_sort(array, 0, len(array) - 1)

```

- 파트 1 예시

```text
1. 첫 번째 호출 (start = 0, end = 4):
피벗: 3 (인덱스 0)
left: 2에서 시작 (인덱스 1)
right: 4에서 시작 (인덱스 4)

첫 번째 내부 반복:
- left는 2에서 출발하여 5를 만납니다 (피벗보다 큼) -> 멈춤.
- right는 4에서 출발하여 4를 만납니다 (피벗보다 큼) -> 왼쪽으로 이동 -> 1에서 멈춤 (피벗보다 작음).
이때 left와 right를 비교합니다 (left = 2, right = 3)인덱스. 아직 인덱스 left <= right이므로 array[left]와 array[right]를 교환합니다.
배열 상태: [3, 2, 1, 5, 4]
두 번째 내부 반복:
left는 5에서 멈춤 (피벗보다 큼).
right는 1에서 왼쪽으로 이동 -> 2에서 멈춤 (피벗보다 작음).
이제 left > right입니다. 이 시점에서 피벗(3)과 right 위치의 값(2)을 교환합니다.
배열 상태: [1, 2, 3, 5, 4]
피벗 3이 자신의 올바른 위치에 놓였습니다.
이제 피벗을 기준으로 배열을 두 부분으로 나눕니다:

왼쪽 부분: [1, 2] (인덱스 0 ~ 1)
오른쪽 부분: [5, 4] (인덱스 3 ~ 4)
```

### ⏱ 계수 정렬

- 빠름, 간단함
- 단, 정수형 형태로 표현할 수 있을 때만 사용 가능
    - 데이터의 크기와 범위가 제한됨
- 가장 큰 데이터와 작은 데이터의 차이가 1,000,000을 넘지 않아야함
- 데이터의 크기를 바교하여 정렬하는 알고리즘이 아님 : 요소가 몇번 등장했는지 기록하여 정렬한다.

1. 데이터의 최댓값을 찾아 계수 배열의 크기를 결정한다.
2. 계수 배열을 0으로 초기화한다.
3. 데이터를 순회하여 각 요소가 몇번 등장하는지 계수 배열에 업데이트한다.
4. 정렬된 결과를 출력한다.  
출력은 등작 횟수만큼 인덱스 번호를 출력하면 된다.  
ex) '0' 인덱스 값이 2라면 -> 0 0
```python
array = [7, 4, 1, 9, 1, 2, 0, 6, 3, 3, 2]

# 가장 큰 데이터+1 크기의 배열 선언 및 0으로 초기화
count = [0] * (max(array) + 1)

# 계수 배열에 데이터 등장 횟수 만큼 (데이터 = 인덱스) 횟수 업데이트
for i in range(len(array)):
    count[array[i]] += 1

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end='')
```
    결과 :  0 0 1 1 2 2 3 4 5 5 6 7 8 9 9


- 로직 예시
```text
만약 입력 배열이 [7, 4, 1, 9, 1, 2, 0, 6, 3, 3, 2]이라면, 정렬 과정은 다음과 같습니다:

count 배열 생성: [1, 2, 2, 2, 1, 0, 1, 1, 0, 1]
count 배열을 순차적으로 순회:
0이 1번 등장 -> [0]
1이 2번 등장 -> [0, 1, 1]
2가 2번 등장 -> [0, 1, 1, 2, 2]
3이 2번 등장 -> [0, 1, 1, 2, 2, 3, 3]
4가 1번 등장 -> [0, 1, 1, 2, 2, 3, 3, 4]
6이 1번 등장 -> [0, 1, 1, 2, 2, 3, 3, 4, 6]
7이 1번 등장 -> [0, 1, 1, 2, 2, 3, 3, 4, 6, 7]
9가 1번 등장 -> [0, 1, 1, 2, 2, 3, 3, 4, 6, 7, 9]
결과 배열은 [0, 1, 1, 2, 2, 3, 3, 4, 6, 7, 9]로 오름차순으로 정렬됩니다.

```

---

---

---
## 파이썬의 정렬 라이브러리
- sorted 소스 코드  
```text
변수 = sorted(배열)
```

- sort 소스 코드
```text
배열.sort()
```

- key 정렬하가
```text
array = [('바나나',2),('사과',1)

def setting(data):
    return data[1]
    
result = sorted(array, key = setting)
```
