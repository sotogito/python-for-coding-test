## 다이나믹 프로그래밍, DP
- 복잡한 문제를 작은 하위 문제들로 나누어 푸는 알고리즘  
- 동일한 하위 문제가 여러번 반복될 때, 이를 한번만 계산하여 중복 계산을 방지한다.  
1. 중복 부분 문제 Overlapping Subproblems : 문제를 풀기 위해 동일한 하위 문제가 여러번 반복됨.
2. 최적 부분 구조 Optional Substructure : 문제의 최적 해결 방법이 하위 문제의 최적 해결 방법으로 구성될 수 있음.  
- 주로 두가지 방법으로 구현됨
1. 상향식 접근 (메모이제이션 Memoization)
2. 하향식 접근 (테이블화 Tabulation)


### 참색과 다이나믹 알고리즘의 차이점
1. *중복되는 하위 문제*가 있는지 확인하라 ex)피보나치 수열
2. 최적화 문제가 포함되어 있는지 확인하라
    - 탐색 : 경로를 찾거나 특정 상태에 도달하는 것이 주 목적
    - DP : 최적의 해를 찾는 것이 목적 (최소, 최대)

- 탐색
  - 미로 칮기 : 미로에서 출구까지 경로를 찾는 문제
  - 최단 경로 찾기 : 두 노드 간의 최단 경로를 찾는 문제

- DP
  - 피보나치 수열 : 중복되는 하위 문제를 해결하기 위해 DP 사용
  - 배낭 문제 : 뭏건의 무게와 가치를 고려해 배낭에 넣을 수 있는 최대 가치를 구하는 문제

### DP은 언제 사용할 수 있을까????
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.  
피보나치 수열을 떠올려 비교하면 된다.

---

---

---

## 피보나치 수열
        1 1 2 3 5 8 13 21
이전 두 항의 합을 현재 항으로 설정한다.
        
        an = an-1 + an-2, a1 =1, a2 =1
- 3항간 점화식
- 첫번째 항과 두번째 항의 값은 모두 1이다.

---
### 피보나치 수열애 DP를왜 사용할까?
만약 f(6)값을 궇나다고 가정해보자.

#### 피보나치 수열을 사용하지 않울때
1. f(6)을 구하기 위해 f(5)와 f(4)를 호출해야됨,
2. 하지만 f(5)를 구하기 위해서 f(4)+f(3), f(4)를 위해 f(3)+f(2).....

계속 꼬리물기 식으로 계산이 필요하다.

```python
def fibo(x):
    if x==1 or x==2:
        return 1
    return fibo(x-2) + fibo(x-1)

print(fibo(4))
```
#### DP로 풀었을 때
1. f(1)과 f(2)는 이미 기본 값(1)으로 알고 있으므로 따로 계산하지 않아됨
2. f(3) 구하고 저장
3. f(4) 계산에서 저장한 f(3) 재사용
4. f(5) 계산에서 저장한 f(4),f(3)을 바로 참조하여 계산
 즉! _**중복 계산을 피하고, 이전에 구한 값을 재사용_**하여 간단하게 구할 수 있다.  


### 메모이제이션(캐싱)
다이나믹 프로그래밍을 구현하는 방법 중 하나로,  
한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 호출하여 재사용하는 방식을 말한다.

- 재귀를 사용한 DP
```python
# 한번 계산된 결과를 메모이제이션 하기 위한 배열
d = [0] * 100


def fibo(x):
    # 기저 조건
    if x == 1 or x == 2:
        return 1

    # 이미 계산했을 때
    if d[x] != 0:
        return d[x]

    # 계산하지 않은 문제
    elif d[x] == 0:
        d[x] = fibo(x - 1) + fibo(x - 2)  # 계산한 값은 d배열에 저장해야함
        return d[x]


print(fibo(1000))
```
만약 f(5)를 계산한다고 가정하면 f(4)과 f(3)은 이미 계산되어 d배열에 저장되었으므로 재사용하여 계산하면 된다.  

DP를 사용했을 때 더 효율적이지만, 재귀를 사용하면 함수를 다시 호출했을 떼 메모리에 적재되기 떄문에 오버헤드가 일어날 수 있다.  

### 탑다운 방식 = 재귀 + 메모이제이션(DP)
큰 문제를 먼저 해결하고, 작은 하위 문제들로 나누어가며 계산하는 방식  
예를들어 fibo(6)을 계산하기 위해 fibo(5)와 fibo(4)를 구한다.


### 바텀업 방식  = 반복문 + 테이블화(DP)
다이나믹 프로그램의 전형적인 현태는 하향식이라고도 불리는 바텀업이다.
```python
d = [0]*100

d[1] = 1
d[2] = 2
n = 99

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

# 반복문으로 d배열의 값을 다 생성해 둔 후 호출해서 답을 찾음
print(d[n])
```




### 재귀보다 반복문을 이용한 DP가 성능이 더 좋다
